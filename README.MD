По возрастанию сложности 

1, 5, 2, 3, 4

### Быстрый вывод на языке Python

Рекомендуется рассмотреть возможность вывода данных с помощью комбинации:

- сбор всех результирующих данных в один массив 

- приведение элементов данного массива к строкам:

- "скрепление" данных строк с помощью функции "join" у выбранного разделителя

В качестве примера: вывод массива целых чисел "ans" в формате "каждое число на новой строке":
```
ans_str = "\n".join(map(str, ans))

print(ans_str)
```
### Быстрый ввод на языке Java
На больших объемах данных Scanner начинает проседать по производительности.

Рекомендуется рассмотреть возможность использования BufferedReader (возможно вам еще приглянется класс StringTokenizer).

Пример ввода с BufferedReader есть в справке Яндекс.Контеста

В случае необходимости ускорения вывода можно использовать любой буферизованный вывод (PrintWriter / BufferedWriter). Единственное условие - не забудьте закрыть поток после вывода ^_^

### Быстрый ввод / вывод на С++
При сомнениях в скорости ввода/вывода через cin/cout можете попробовать использовать следующее ускорение:
```
	ios::sync_with_stdio(false);

	cin.tie(nullptr);
```
(вызывается в начале выполнения программы)

Этот код отключает синхронизацию с printf/scanf и синхронизацию потоков cin/cout между собой.

Также напоминаем, что endl вызывает внутри себя flush, что может негативно сказаться на скорости выполнения работы программы (рекомендуется использовать "\n" при необходимости)

### Тесты из условия
Тесты, предоставленные в условии, совпадают с первыми тестами, на которых будет тестироваться ваша программа.

Если у вас ошибка на одном из этих тестов - у вас есть эти данные в условии, проверьте их.

Ответы на эти (и все остальные тесты) сгенерированы авторскими решениями и являются правильными. 

К данным тестам есть пояснения, которые описывают получение каждого ответа на соответствующий тест (с разной степенью детализации).

### Тесты НЕ из условия
Все тесты, не предоставленные в условии, не доступны для просмотра участниками. 

В то же время все эти тесты удовлетворяют всем ограничениям и другим гарантиям, указанным в разделе "Формат входных данных".

Проверять данные гарантии в коде программы не нужно - это гарантия от авторов задач участникам. 

### Итоговая оценка
Задача считается решенной, если она решена полностью (прошла все тесты и получила вердикт ОК).

Любой другой вердикт не засчитывает задачу.

### Эффективность решений
Алгоритм, реализованный в вашей программе, должен иметь достаточную эффективность, чтобы пройти ограничения по времени и памяти.

Эффективность обычно оценивается в терминах "большого О" (встречается еще термин "асимптотика"). 

Если вам незнакомы данные понятия, то советуем ознакомиться с ними и уточнить, сколько базовых операций в секунду в среднем может выполнять ваш язык программирования.

### Тестирование решений
Решения тестируются по очереди на представленных в системе тестах (тесты из условия являются их частью).

Если решение "падает" на одном из тестов, то оно считается частичным и не засчитывается. Тестирование прерывается на первом непройденном тесте.

Если решение проходит все тесты - оно считается "полным" и вы получаете вердикт ОК.

### Возможные вердикты
- OK - задача зачтена. 

Если вы получили по задаче ОК, то его не уже не отнимут, даже если вы перепошлете на ту же задачу неверное решение.

- CE - compilation error - ошибка компиляции. Вы можете просмотреть ошибку, выдаваемую компилятором.

- WA - wrong answer - неправильный ответ

- RE - runtime error - ошибка исполнения (деление на ноль, выход за границу массива и т.д.)

- TL - time limit - превышено ограничение по времени (на тест) 

- ML - memory limit - превышено ограничение по памяти (на тест)

- PE - presentation error - частный случай WA, когда вывод в несовпадающем с ожидаемым формате

- и т.д.

#### Вердикты TL и ML и использованные ресурсы
Если вы получаете вердикты TL / ML, то вы можете увидеть рядом с вердиктом время / память, очень близкие к указанным в задаче.

К примеру, вы можете увидеть TL (2.005 сек) при ограничении в 2 секунды.

Это НЕ значит, что ваша программа работала всего лишь на 0.005 секунд дольше.

Это значит, что вашу программу ОСТАНОВИЛИ через 0.005 секунд после выхода за ограничения по времени.

Мы постарались выставить ограничения таким образом, чтобы корректное решение без каких-либо специфических НЕАСИМПТОТИЧЕСКИХ оптимизаций (кроме оптимизаций ввода/вывода, указанных в других оповещениях) проходило примерно за половину выделенных времени и памяти.

### Недоступность внешних библиотек (numpy, pandas, boost и др.)
Для использования доступны лишь библиотеки / модули, входящие в стандартную сборку указанного компилятора.

Внешние библиотеки (которые необходимо устанавливать отдельно) НЕДОСТУПНЫ для использования в программе.

Примерами таких НЕДОСТУПНЫХ библиотек являются:

- numpy

- pandas

- boost

### Выбор компилятора для языка Java
Все авторские решения тестировались, в первую очередь, на компиляторе Java 15. Именно по данному компилятору настраивались ограничения по времени и памяти.

Единственным исключением является задача C, для отправки решений по которой доступен компилятор "Java 8 + network + json".

### Примеры ввода и вывода
Обращаем ваше внимание, что примеры кода на различных языках для ввода / вывода из файла / консоли можно найти в справке к Яндекс.Контесту:

https://yandex.ru/support/contest/examples-stdin-stdout.html